
欢迎来到『九章算法班 2021 版』的第11节课，今天我们一起来学习『宽度优先搜索与图论入门』

在第十章的学习中，我们掌握了“队列”这种数据结构的实现方法和相关面试题目。那么基于之前的内容，这一章我们将首先引入一种面试中的热门算法——宽度优先搜索（简称BFS）算法。在学习了BFS的应用场景以及各种实现方法之后，我们还要接触一类全新的概念：图。除了了解图的基础知识外，还要对学习如何建立图以及存储图。

# 宽度优先搜索BFS的3种适用场景

"第十一章【互动】宽度优先搜索与图论入门1_BFS的3种适用场景.mov"

- 分层遍历
- 连通块问题
- 拓扑排序

<img src="chapter11_1.png" width=400>


以下哪些问题BFS可以处理的：

- A: 二叉树的层次遍历
- B: 求出边长均为5的图的最短路径
- C: 求出边长全不相等的图的最短路径
- D: 二叉树的先序遍历
- E: 求出01矩阵上最大的全0块
- F: 我不会写递归，但是我需要求从10个数中任意拿出5个的所有方案。

先序遍历通常使用递归方式来实现，即使使用非递归方式，也是借助栈来实现的，所以并不适合BFS，而层次遍历因为是一层一层的遍历，所以是BFS十分擅长的；边长一致的图是简单图，所以可以用BFS，因此B可以，因为BFS只适用于简单图，所以C不可以；矩阵连通块也是BFS可以处理的问题，求出最大块只需要维护一个最大值即可；选项F属于求所有方案问题，因此可以用BFS来处理，但是并不是唯一的解决方式。

答对啦！正确答案是 A B E F

# BFS的三种实现方法
- 单队列 （最简单，最推荐）
- 双队列
- DummyNode


# 使用单队列方法实现BFS

第十一章【互动】宽度优先搜索与图论入门2_BFS的3种实现方法1_单队列方法.mov

[69. Binary Tree Level Order Traversal](../lintcode/69.Binary_Tree_Level_Order_Traversal.md)


<img src="chapter11_2.png" >

# 使用双队列方法实现BFS

第十一章【互动】宽度优先搜索与图论入门3_BFS的3种实现方法2_双队列方法.mov

同样的问题双队列解决：
<img src="chapter11_3.png">

# 使用用DummyNode思想实现BFS


如果你已经用三种方式AC了上述题目，那么你已经基本掌握了BFS的实现与使用方法。

你最喜欢哪种BFS的实现方式呢？
A: 简洁有效，单队列一生推
B: 直白易懂，双队列无敌
C: 缩进优雅，DummyNode颜值粉
D: 啥是BFS，DFS它不香吗

--- 
下面让我们继续学习有关图的知识。

# 图

什么是图（Graph）？

图在离线数据中的表示方法为 ```<E, V>```，E表示 Edge，V 表示 Vertex。也就是说，图是**顶点（Vertex）和边（Edge）的集合**。

图分为：
- 有向图（Directed Graph）
- 无向图（Undirected Graph）

BFS 大部分的时候是在图上进行的。

BFS 在两种图上都适用。另外，树（Tree）也是一种特殊的图。

下图中左为无向图，右为有向图。
<img src="chapter11_4.png">

# 二叉树的BFS vs 图的BFS：

二叉树中进行 BFS 和图中进行 BFS 最大的区别就是二叉树中无需使用 HashSet（C++: unordered_map, Python: dict) 来存储访问过的节点（丢进过 queue 里的节点）

因为二叉树这种数据结构，上下层关系分明，没有环（circle），所以不可能出现一个节点的儿子的儿子是自己的情况。

但是在图中，一个节点的邻居的邻居就可能是自己了。